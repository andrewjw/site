---
layout: post
title: Creating Django Management Commands
date: 2009-03-06 13:32:51.000000000 +00:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- web development
tags:
- admin
- django
- tool
meta:
  _edit_last: '364050'
  _wpas_skip_twitter: '1'
author:
  login: andrewjw
  email: andrewjwilkinson@gmail.com
  display_name: Andrew Wilkinson
  first_name: Andrew
  last_name: Wilkinson
permalink: "/2009/03/06/creating-django-management-commands/"
---
<p>Creating a website with Django is great fun, but eventually you'll need to write a tool to clean up you data, expire old users or one of the myriad of other administration tasks that are involved with running a website.</p>
<p>You'll be very used to using manage.py to create your database and to run your webserver. It make sense to use the same script for your own admin tools. Not only to get the benefit of sharing lots of you code but also Django will take care of parsing command line arguments and importing your settings for you.</p>
<p>Unfortunately the <a href="http://docs.djangoproject.com/en/dev/howto/custom-management-commands/#howto-custom-management-commands">Django documentation</a> is quite lacking on how to add your own command, but it's really quite easy.</p>
<p>If your app is in <tt>project/app</tt> then create the directories <tt>project/app/management/commands</tt>. Create an empty file called <tt>__init__.py</tt> in both the <tt>management</tt> and <tt>commands</tt> directories. Once you've done that every other python file in the commands directory can be executed via <tt>manage.py</tt>. If you create the file <tt>project/app/management/commands/x.py</tt> then it can be run as <tt>manage.py x</tt>.</p>
<p>Each file which contains a command must define a class called <tt>Command</tt> which derives from <tt>django.core.management.base.BaseCommand</tt>. Rather than derive directly from <tt>BaseCommand</tt> you'll most likely want to derive from <tt>NoArgsCommand</tt>, <tt>LabelCommand</tt> or <tt>AppCommand</tt>. First I'll explain how to make a command when deriving from <tt>BaseCommand</tt> and then we'll look at the helper classes.</p>
<pre>
from optparse import make_option
from django.core.management.base import BaseCommand, CommandError

class Command(BaseCommand):
    option_list = BaseCommand.option_list + (
        make_option('--long', '-l', dest='long',
            help='Help for the long options'),
    )
    help = 'Help text goes here'

    def handle(self, **options):
         print "This is a command"
</pre>
<p>The code above should be fairly self explanatory. The code for your command goes inside the handle function, while the options that your command accepts go in the options_list variable above. In this example the code accepts one option, long, which will be passed as a value in the options dictionary.</p>
<p>If you command doesn't need any options then you should derive from NoArgsCommand and override handle_noargs rather than handle.</p>
<p>The other two types of commands are AppCommand and LabelCommand. These both take any number of arguments on the commandline, but AppCommand checks that they are app names while LabelCommand passes them on unchanged. You should override handle_app and handle_label rather than handle, and these functions will be called once for each commandline argument with the argument as the first parameter to the function.</p>
<p>For more inspiration take a look at the <a href="http://code.djangoproject.com/svn/django/trunk/django/core/management/commands/">default management commands</a>.</p>
<p>Next time I'll show how you can write a real command which will help you keep your views updated if you use couchdb as a datastore.</p>
